import asyncio
import json
import aiohttp 
from enum import Enum
from copy import deepcopy
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Mapping, Optional,Dict,List,Union
from abc import ABC, abstractmethod
import time
import exchanges


class RESTMethod(Enum):
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"

    def __str__(self):
        obj_str = repr(self)
        return obj_str

    def __repr__(self):
        return self.value


@dataclass
class RESTRequest:
    method: RESTMethod
    url: Optional[str] = None
    endpoint_url: Optional[str] = None
    params: Optional[Mapping[str, str]] = None
    data: Any = None
    headers: Optional[Mapping[str, str]] = None
    is_auth_required: bool = False
    throttler_limit_id: Optional[str] = None


@dataclass(init=False)
class RESTResponse:
    url: str
    method: RESTMethod
    status: int
    headers: Optional[Mapping[str, str]]

    def __init__(self, aiohttp_response: aiohttp.ClientResponse):
        self._aiohttp_response = aiohttp_response

    @property
    def url(self) -> str:
        url_str = str(self._aiohttp_response.url)
        return url_str

    @property
    def method(self) -> RESTMethod:
        method_ = RESTMethod[self._aiohttp_response.method.upper()]
        return method_

    @property
    def status(self) -> int:
        status_ = int(self._aiohttp_response.status)
        return status_

    @property
    def headers(self) -> Optional[Mapping[str, str]]:
        headers_ = self._aiohttp_response.headers
        return headers_

    async def json(self) -> Any:
        json_ = await self._aiohttp_response.json()
        return json_

    async def text(self) -> str:
        text_ = await self._aiohttp_response.text()
        return text_


class RESTConnection:
    def __init__(self, aiohttp_client_session: aiohttp.ClientSession):
        self._client_session = aiohttp_client_session

    async def call(self, request: RESTRequest) -> RESTResponse:
        aiohttp_resp = await self._client_session.request(
            method=request.method.value,
            url=request.url,
            params=request.params,
            data=request.data,
            headers=request.headers,
        )

        resp = await self._build_resp(aiohttp_resp)
        return resp

    @staticmethod
    async def _build_resp(aiohttp_resp: aiohttp.ClientResponse) -> RESTResponse:
        resp = RESTResponse(aiohttp_resp)
        return resp

class AuthBase(ABC):
    """A base class for authentication objects that can be fed to the `WebAssistantsFactory`.
    Hint: If the authentication requires a simple REST request to acquire information from the
    server that is required in the message signature, this class can be passed a `RESTConnection`
    object that it can use to that end.
    """

    @abstractmethod
    async def rest_authenticate(self, request: RESTRequest) -> RESTRequest:
        ...

class RESTAssistant:

    def __init__(
            self,
            connection: RESTConnection,
            auth: Optional[AuthBase] = None
    ):
        self._connection = connection
        self._auth = auth

    async def execute_request(
            self,
            url: str,
            throttler_limit_id: str,
            params: Optional[Dict[str, Any]] = None,
            data: Optional[Dict[str, Any]] = None,
            method: RESTMethod = RESTMethod.GET,
            is_auth_required: bool = False,
            return_err: bool = False,
            timeout: Optional[float] = None,
            headers: Optional[Dict[str, Any]] = None) -> Union[str, Dict[str, Any]]:
        
        headers = headers or {}

        local_headers = {
                "Content-Type": ("application/json" if method != RESTMethod.GET else "application/x-www-form-urlencoded")}
        local_headers.update(headers)

        data = json.dumps(data) if data is not None else data
        
        request = RESTRequest(
                    method=method,
                    url=url,
                    params=params,
                    data=data,
                    headers=local_headers,
                    is_auth_required=is_auth_required,
                    throttler_limit_id=throttler_limit_id
        )

        response = await self.call(request)

        if 400 <= response.status:
            if return_err:
                error_response = await response.json()
                return error_response
            else:
                error_response = await response.text()
                error_text = "N/A" if "<html" in error_response else error_response
                raise IOError(f"Error executing request {method.name} {url}. HTTP status is {response.status}. "
                              f"Error: {error_text}")
        result = await response.json()
        return result


    async def call(self, request: RESTRequest, timeout: Optional[float] = None) -> RESTResponse:
        request = deepcopy(request)
        #request = await self._pre_process_request(request)
        request = await self._authenticate(request)
        resp = await asyncio.wait_for(self._connection.call(request), timeout)
        #resp = await self._post_process_response(resp)
        return resp

    async def _authenticate(self, request: RESTRequest):
        if self._auth is not None and request.is_auth_required:
            request = await self._auth.rest_authenticate(request)
        return request

class OrderBookData:

    def __init__(self,
                 trading_pairs: List[str],
                 exchange: exchanges.BinanceUS()):
        super().__init__(trading_pairs)
        self._exchange = exchange
        

    async def _request_order_book_snapshot(self, trading_pair: str) -> Dict[str, Any]:
        """
        Retrieves a copy of the full order book from the exchange, for a particular trading pair.
        :param trading_pair: the trading pair for which the order book will be retrieved
        :return: the response from the exchange (JSON dictionary)
        """
        params1 = {
                "symbol": trading_pair,
                "limit": "1000"
            }

        RA = RESTAssistant(
            connection=RESTConnection(aiohttp_client_session=aiohttp.ClientSession),
            auth=None
        )
        data = RA.execute_request(
            url=self._exchange._rest_url,
            throttler_limit_id='Need to implement',
            params=params1,
            method=RESTMethod.GET
        )
        return data

    async def _order_book_snapshot(self, trading_pair: str):
            snapshot: Dict[str, Any] = await self._request_order_book_snapshot(trading_pair)
            snapshot_timestamp: float = time.time()
            snapshot_msg = {
                'snapshot':snapshot,
                'timestamp':snapshot_timestamp,
                'trading_pair':trading_pair,
                'exchange':self._exchange
                }
                
            return snapshot_msg
